let flashcards = {
  declaration: 'Registaring a name to a variable within a given scope. Note: return value is always undefined when declaring variables, including when initialized and assigned at the same time.',
  initialization: 'Memory is allocated for variable (Automatically done in declaration).',
  assignment: 'Assigning Specific value to variable. Note: returns right hand value unless variable is being declared (let/var/const) on same line in which case it returns undefined.',
  reassignment: 'Assigning a new value to a previously assigned variable. This can be reasignment of Value or Reference, however, mutating an object or array is not reassignment unless it is pointed to a new space in memory.',
  primitive_types: '5 per Launch School: 1. String 2. Number 3. Undefined 4. Null 5. Boolean. (MDN has 7 by including BigInt and Symbol)',
  literals: 'Notation used to represent a fixed value in source code.',
  template_literals: 'use of backticks {\`} to interpolate a varable or expression into text',
  explicit_type_coercion: 'Use of functions to change data types (ex. Number(), parseInt(), parseFloat(), String()',
  const: 'Primitive Values are immutable with const. Arrays and Objects cannot be reassigned with new pointers or deleted. The contents, however, can be mutated. Also, Nested arrays or objects can be reassigned or deleted.',
  strict_equality: 'Comparison operator "===" which returns true if both values are the same type and value.',
  loose_equality: 'Comparison which implicitly converts types of value to match before returning a boolean value. This operator is often hard to predict, so using strict equality is almost always the better decision',
  passing_to_and_from_functions: 'Passes Reference (pointer) or Value (primitive) stored in variable. Shallow Copy of variable passed to Function. The object pointed to cannot be reassigned within the function scope, but the value stored there can be mutated, even when passing by reference.',
  static_methods: 'Accessed directly from Constructor name (ex. String.fromCharCode(97) or Object.keys())',
  instance_method: 'Methods that are called on specific instances of an object or primitive data type (ex. someString.concat(someOtherString) or someArray.forEach()) (Note: displayed as DataType.Protoype.method())',
  string_methods: 'Length',
  statements: 'any single unit of code: declarations, loops, if statements, return/break, assignments, standalone expressions (console.log("hello")',
  expression: 'Must capture a value',
  array: 'Built-in Object using zero-indexed keys to keep track of data.  Arrays always keep items in order and have the most methods for manipulation of values and order of values. Strings and Objects can both be converted into arrays for manipulation.',
  object: 'Data Structure using key indexed values with the syntax { key: value }',
  log_vs_return: 'console.log() has a return value of undefined. It merely prints the value to the terminal. return passes a value or reference back from a function to be used in the rest of your program.',
  truthiness: 'Values which evaluate to true in an "if" clause.',
  falsy_values: 'Only the following: ',
  boolean: 'the literal values true and false. Different than Truthiness and Falsiness',
  pass_by_reference: 'A pointer to a space in memory outside of the local scope is passed in as a fucntion parameter and can thus mutate the original space in memory.  This is why passign arrays and objects as parameters is different from primitive values.',
  pass_by_value: 'passing a primitive value as a parameter to a function. Only a copy of the value is passed and will not mutate the passing variable.',
  pointers: 'When an identifier does not directly store a value, but location in memory where a value is stored. Mutating values reference by pointers will change the underlying value and thus will mutate the value reference by any other variable which points to the same address.',
  identifiers: 'Variable, Constant, Property, Function, and Class names and Function Parameters',
  variable: 'name declared by `let` or `var`. Can be reassigned.',
  constant: 'Name declared by `const` is mutable if not primitive type, but cannot be reassigned.',
  legal_name_requirements: 'No spaces, canonly contain alphanumeric/underscore/dollarsign, may not begin with number, are case-sensitive, cannot be reserved word',
  idiomatic_name_preferences: 'camelCase for variable/const/funct; PascalCase for constructor functions; SCREAMING_SNAKE_CASE for unchanging constants/magicNumbers; using is/are/has for booleans; using descriptive function names such as get/display to identify the function purpose easily',
  block: 'Curly brace enclosed expressions (if/loop). Technically, functions technically have "function body" instead of blocks, but are included under this reference as such often for simplicity.',
  global_scope: 'Any variable or constant declared outside of any blocks.  These variables can be accesed and mutated within blocks the same as they can be outside blocks. To do this, you simply reference the variable and reassign or mutate.',
  shadowing: 'Creating a variable in the local block scope with the same identifier as a global variable. Shadowing is done either by passing a value or reference as a function parameter or declaring with let/var/const within the block to create a new namespace. Shadowing can be done in if, loop, method, or function blocks.',
  local_scope: 'shen declaring a variable within a block or passing in function paramaters as variables, these are only available within the scope of the block (the exception is when a parameter is passed by reference and points to memory that exists outside of the local scope).',
  function_purpose_vs_implementation: 'Describing the Inputs and Outputs of a function and any limitations on either.',
  function_parameters: 'The names between parentheses. They are not required, and can be numerous. They either pass a copy of a value or a reference to a value outside the function body to be passed into the fuction body as a local variable name matching the parameter name.',
  function_definition: 'Functions can be defined three ways: Declaration, Expression or Arrow.',
  function_invocation: 'When a function is called or invoked, it is referenced in the global scope, another invoked function, or as an immediately invoked function within a method. The reference uses the function name and (if applicable) paremeters unless immediately invoked, in which case the function is defined and invoked simultaneously.',
  return_values: 'The value returned by the function must be returned with the "return" keyword to be passed to the location if the function call in the program. The only exception is with arrow functions. If not specifed, functions automatically default to an undefined return value',
  predicates: 'functions which always return boolean values',
  default_parameters: 'within parameters, use syntax (param = "default", param2 = "default")',
  nested_functions: 'Can only be called within the scope of ther function body in which they are defined.',
  function_declaration: 'function must be first word. Benefits: Can be accessed anywhere in the current or inner scopes (do not need to declare above the call). ex. function greet() {}.',
  function_expression: 'Using let or const to assign function to a variable.  Like all variables, must be defined in program before invocation. ex. let greet = function() {} OR (function greet() {})',
  arrow_function: 'let functionName = (a, b) => implicitReturnValue; or => { //multilinecode with return statement }',
  implicit_return: 'Arrow functions with one expression may implicitly return a value',
  first_class_function: 'ability to treat function as a variable.  Functions are objects so they can be passed as arguments to other functions and returned from other functions.',
  operator_precedence: 'Comparison => Equality => AND => OR',
  tarnary_operator: 'conditional ? value if true : value if false',
  objects: 'collection of key-value pairs',
  object_properties: 'Another name for key or key-value pair in an object',
  mutability: 'Ability for a data type to be changed. Primitive types are immutable and can only be reassigned.  Objects and Arrays are mutable, even if declared as constants. Some methods will mutate the caller also, which can be determined by reading the documentation.',
}